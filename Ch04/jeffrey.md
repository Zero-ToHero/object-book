# 4. 설계 품질과 트레이드오프
## 시스템을 객체로 분할하기
### 데이터 중심의 관점

데이터를 조작하는 데 필요한 오퍼레이션을 정의

- 객체의 **상태에 초점**을 맞추고, 독립된 데이터 덩어리로 바라본다.
- 객체가 포함해야 하는 **데이터에 집중**한다.
    
    → 객체의 종류를 저장하는 인스턴스 변수와 인스턴스 종류에 따라 배타적으로 사용될 인스턴스 변수를 하나의 클래스 안에 함께 포함시키는 방식으로 흔히 설계.
    
- 캡슐화를 위해 **내부의 데이터를 반환**하는 `접근자`와 **데이터를 변경**하는 `수정자`를 추가

### 책임 중심의 관점

다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관

- 객체의 행동에 초점을 맞추고, 협력하는 공동체의 일원으로 바라본다.

<br>

## 설계 트레이드오프

### 캡슐화

- 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 **추상화의 한 종류**.
- 객체를 설계하기 위한 가장 기본적인 아이디어
    1. 변경의 정도에 따라 구현과 인터페이스를 분리
        - 구현 : 나중에 변경될 가능성이 높은 어떤 것을 가리킴.
        - 인터페이스 : 상대적으로 안정적인 부분.
    2. 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것.
- 설계가 필요한 이유 → 요구사항이 변경되기 때문
    
    캡슐화가 중요한 이유 → 변경의 영향을 통제할 수 있기 때문
    

즉, 캡슐화는 **변경 가능성이 높은 부분**을 객체 내부로 숨기는 추상화 기법.

**변경될 수 있는 어떤 것이라도 캡슐화**해야 한다.

- 유지보수성 : 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있는 능력.

### 응집도와 결합도

**응집도**

- 모듈에 포함된 **내부 요소들이 연관돼 있는 정도**
- 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.
- 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도를 측정할 수 있다.
    - 응집도가 높을 경우
        - 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다
        - 하나의 변경에 대해 하나의 모듈만 변경된다
        - 변경의 대상과 범위가 명확해서 코드 변경이 쉽다.
    - 응집도가 낮을 경우
        - 하나의 변경을 수용하기 위해 모듈의 일부만 변경된다
        - 하나의 변경에 대해 다수의 모듈이 함께 변경돼야 한다
        - 변경의 대상과 범위가 명확하지 않아서 코드 변경이 어렵다.

**결합도**

- 의존성의 정도를 나타냄
- 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
- 객체 또는 클래스가 **협력에 필요한 적절한 수준의 관계만을 유지하고 있는지**를 나타낸다.
- 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
    - **하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지**를 나타낸다.
    - 결합도가 높을 경우
        - 내부 구현을 변경했을 때 다른 모듈에 영향을 미침
    - 결합도가 낮을 경우
        - 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향을 미침
- **변경될 확률이 매우 적은 안정적인 모듈**에 의존하는 것은 문제가 되지 않는다.
    - e.g.) 표준 라이브러리에 포함된 모듈, 성숙 단계에 접어든 프레임워크

**좋은 설계**

- 오늘의 기능을 수용하면서 내일의 변경을 수용할 수 있는 설계
- 응집도와 결합도는 변경과 관련된 것.

<br>

## 데이터 중심 설계의 문제점

**캡슐화를 위반**하고 객체의 **내부 구현을 인터페이스의 일부로 만든다.**

### 캡슐화 위반

접근자와 수정자 메서드는 객체 내부의 상태에 대한 어떤 정보도 캡슐화하지 못한다.

- **인스턴스 변수의 존재를 퍼블릭 인터페이스에 노골적으로 드러냄.**
- 접근자와 수정자에 과도하게 의존하는 설계방식인 추측에 의한 설계 전략으로, 변경에 취약한 설계를 얻게 된다.

### 높은 결합도

- 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다.
- 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중되기 때문에, 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합.
    - 이 결합도로 인해 어떤 데이터 객체를 변경하더라도 제어 객체를 함께 변경할 수 밖에 없음.

### 낮은 응집도

- **서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존**할 때 모듈의 응집도가 낮다고 말함
- 낮은 응집도는 두 가지 측면에서 설계 문제를 일으킨다.
    - 변경과 아무 상관이 없는 코드들이 영향을 받음
    - 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 함.
- SOLID의 SRP는 응집도를 높일 수 있는 설계 원칙

### 자율적인 객체

- 객체를 하나의 단위로 묶는 이유는, 스스로 자신의 상태를 처리할 수 있게 하기 위함.
    - 내부에 저장된 데이터보다 협력에 참여하여 수행할 책임을 정의하는 오퍼레이션이 더 중요.
- 객체 설계 시, 두 질문으로 분리
    - 어떤 데이터를 포함해야 하는가?
    - 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
    
    → 두 질문을 조합하면 새로운 데이터 타입을 만들 수 있음
    

### 데이터 중심의 설계가 변경에 취약한 이유

- 너무 이른 시기에 데이터에 관해 결정하도록 강요
    - 너무 이른 시기에 내부 구현에 초점을 맞추게 되어, **데이터와 기능을 분리**하는 절차적 프로그래밍 방식을 따르게 된다.
    - 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하다보니, **데이터에 관한 부분이 인터페이스에 고스란히 드러나게 된다.**
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정
    - 데이터 중심 설계에서 초점은 객체의 외부가 아닌 내부로 향함.
        - 문맥에 대한 고민 없이 객체가 관리할 데이터의 세부 정보를 먼저 결정
    - 이미 구현된 객체의 인터페이스를 억지로 끼워맞출 수밖에 없다.
    - 객체의 인터페이스에 구현이 노출돼 있기에, 협력이 구현 세부사항에 종속된다.
        - 내부 구현이 변경됐을 때, 협력하는 객체 모두가 영향을 받을 수 밖에 없다.