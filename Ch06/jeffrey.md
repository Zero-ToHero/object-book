# 6. 메시지와 인터페이스
### 메시지와 메시지 전송

- 메시지
    - 객체들이 협력하기 위해 사용할 수 있는 유일한 **의사소통 수단**
    - 협력에 참여하는 전송자와 수신자 양쪽 모두를 포함하는 개념
    - `오퍼레이션명`과 `인자`로 구성
    - e.g.) isSatisfiedBy(screening)
- 메시지 전송(메시지 패싱)
    - 한 객체가 다른 객체에게 **도움을 요청**하는 것
    - `오퍼이션명`과 `인자`, `메시지 수신자`로 구성
    - e.g.) condition.isSatisfiedBy(screening)

<br>

### 메시지와 메서드

메시지 수신 시, 메시지 수신자의 실제 타입에 따라 실행되는 코드가 달라짐.

- 메서드
    - 메시지를 수신했을 때 **실제로 실행되는 함수 또는 프로시저**
    - 전통적인 방식은 코드의 의미가 컴파일 시점과 실행 시점이 동일하나, 객체는 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
        - 동일한 오퍼레이션이라도 메서드는 다를 수 있다.
    - 오퍼레이션의 구현
    - 다형성의 개념과 연결

<br>

### 퍼블릭 인터페이스와 오퍼레이션

- 퍼블릭 인터페이스
    - 객체가 의사소통을 위해 **외부에 공개하는 메시지의 집합**
    - 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음
    - 인터페이스의 각 요소는 오퍼레이션
- 오퍼레이션
    - 퍼블릭 인터페이스에 포함된 메시지
    - 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분
    - 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세
    - 구현이 아닌 **추상화**. 메서드가 오퍼레이션에 대한 구현
    - 메시지 전송자는 고려하지 않고 **메시지 수신자의 관점만을 다룬다.**
    - 메시지가 전송자와 수신자 사이의 **협력 관계를 강조**하지만, 오퍼레이션은 메시지를 수신하는 객**체의 인터페이스를 강조**
- 시그니처
    - 오퍼레이션이나 메서드의 명세를 나타낸 것
    - `오퍼레이션의 이름`과 `파라미터 목록`을 합친 것.
    - 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것.
    - 메서드는 시그니처에 구현을 더한 것.

<br>

### 디미터 법칙

협력하는 객체의 내부 구조에 대한 **결합으로 인해 발생하는 설계 문제**를 해결하기 위해 제안된 원칙

- 내부 구조에 **강하게 결합되지 않도록** 협력 경로를 제한
- 아래 조건을 만족하는 인스턴스에만 메시지를 전송
    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션의 요소
    - 메서드 내에서 생성된 지역 객체
- shy code : 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드
- 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 전송자는 수신자의 내부 구현에 결합되지 않는다.
- 기차 충돌 : 연쇄적으로 메시지를 전송
- 객체는 디미터 법칙을 따르는 것이 옳지만, 자료 구조라면 당연히 내부 구조를 노출해야 하므로 적용할 필요가 없다.

<br>

### 묻지 말고 시켜라 스타일

- 객체의 상태에 관해 묻지 말고 원하는 것을 시키는 스타일의 메시지 작성
- 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상

<br>

### 메시지 명명법

1. 작업을 어떻게 수행하는지를 나타내도록 짓기 → 내부의 구현 방법을 드러냄
    - 메서드에 대해 제대로 커뮤니케이션하지 못한다.
    - 캡슐화 위반
        - 협력하는 객체의 종류를 알도록 강요
        - 방법이 변경되면 메서드의 이름도 변경해야 하며, 코드도 함께 변경될 수 있음.
2. **`어떻게`가 아니라 `무엇`을 하는지 드러내기 (의도를 드러내는 선택자)**
    - 어떻게 → 메서드의 내부 구현을 설명함
    - 무엇 → 객체가 협력 안에서 수행해야 하는 책임에 대해 고민하여 짓게 함
        - 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커져 유연한 협력을 얻게 됨.

<br>

### 의도를 드러내는 인터페이스

- **구현과 관련된 모든 정보를 캡슐화**하고, 객체의 **퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현**해야 한다는 것
- 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여

<br>

### 명령-쿼리 분리 원칙

퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공

- 루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
- 프로시저 : 정해진 절차에 따라 **내부의 상태를 변경**하는 루틴의 한 종류
    - 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
- 함수 : 어떤 절차에 따라 **필요한 값을 계산해서 반환**하는 루틴의 한 종류
    - 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
- 명령과 쿼리
    - 명령 : 객체의 상태를 수정하는 오퍼레이션
        - 인터페이스 측면에서 `프로시저`
    - 쿼리 : 객체와 관련된 정보를 반환하는 오퍼레이션
        - 인터페이스 측면에서 `함수`
    - 명령인 동시에 쿼리여서는 안 된다.
- 명령-쿼리 인터페이스
    - 명령-쿼리 분리 원칙에 따라 작성된 객체의 인터페이스
- 참조 투명성
    - `어떤 표현식 e`가 있을 때, `e`의 값으로 `e`가 나타나는 **모든 위치를 교체하더라도 결과가 달라지지 않는** 특성
    - **명령과 쿼리를 분리**함으로써 참조 투명성의 장점을 제한적이나마 누릴 수 있다.
    - 버그가 적고, 디버깅이 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.
    - 장점
        - 식을 쉽게 계산할 수 있다.
        - 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
    - 수학적인 함수는 참조 투명성을 엄격하게 준수하는 가장 유명한 체계
    - 함수형 프로그래밍 또한 부수효과가 존재하지 않고 참조 투명성의 장점을 극대화할 수 있는 수학적인 함수에 기반.
        - 병렬 처리가 중요해진 최근에는 race condtion 등의 문제로 인해 함수형 프로그래밍 패러다임을 접목시키고 있는 추세