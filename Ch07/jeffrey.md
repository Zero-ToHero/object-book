# 7.  객체 분해
### 프로시저 추상화

- 소프트웨어가 `무엇`을 해야하는지를 추상화
- 기능 분해 (알고리즘 분해)
    - 추상화의 단위는 프로시저. 시스템은 프로시저를 단위로 분해된다.
    - `기능을 중심`으로 필요한 데이터를 결정
- 하향식 접근법
    - 가장 최상위 기능을 정의하고, 좀 더 작은 단계의 하위 기능으로 **분해**해 나가는 방법
    - 기능 분해를 위한 하향식 접근법
        - 먼저 필요한 기능을 생각하고, 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별
- 하향식 기능 분해의 문제점
    - 시스템은 하나의 메인 함수로 구성돼 있지 않다.
        - 지속적 기능 추가로 메인 함수와 동등한 여러 함수들이 생겨나는 현대적인 상호작용 시스템 개발에 부적합.
    - 메인 함수를 **빈번하게 수정**해야 한다.
        - 위와 같은 정상인 메인 함수가 추가되면, main 함수 내부 구현이 수정되면서 기존 코드에 영향을 끼쳐 버그 유발.
    - `비즈니스 로직`과 `사용자 인터페이스`가 **강하게 결합**된다.
        - 사용자 인터페이스는 자주 변경되는 부분이나, 비즈니스 로직은 상대적으로 적게 발생. 사용자 인터페이스 변경이 비즈니스 로직의 변경에도 영향을 끼침.
    - 너무 이른 시기에 함수들의 실행 순서를 고정시켜 유연성과 재사용성 저하
        - 설계의 시작점부터 시스템이 무엇을 해야하는지가 아니라 어떻게 동작해야 하는지에 집중하도록 만듦.
        - 하향식 접근법은 처음부터 `구현`을 염두에 두어 시간 제약을 강조
        - 전체 시스템의 핵심적인 구조를 결정하는 함수들이 데이터와 강하게 결합됨.
        - 이를 해소하기 위해, 객체지향의 논리적 제약을 설계의 기준으로 삼아 논리적인 관계를 중심으로 설계를 이끌어 나가면, 제어 주체를 분산할 수 있다.
    - 데이터 형식이 변경될 경우 파급 효과를 예측할 수 없다.
        - 어떤 데이터를 어떤 함수가 사용하고 있는지 추적이 어려움. 이로인해, 데이터 변경으로 어떤 함수가 영향을 받을지 예상이 어렵다.
        - 영향을 최소화하려면, 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리하고, 퍼블릭 인터페이스를 통해 변경되는 부분에 대한 접근을 통제해야 한다.
- 하향식 분해가 유용할 때
    - **작은 프로그램**과 **개별 알고리즘**을 위해서는 유용한 패러다임

<br>

### 모듈

- 모듈과 기능 분해는 상호 배타적인 관계가 아니다.
    - 시스템을 모듈로 분해 후, 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.
- 시스템을 모듈 단위로 분해
    1. 시스템이 감춰야 하는 비밀을 찾자.
    2. 외부에서 내부의 비밀에 접근하지 못하도록 하자. → 퍼블릭 인터페이스
- `복잡성`, `변경 가능성`에 대한 비밀을 감춰야 한다.
- 비밀은 `데이터`, `복잡한 로직`, `변경 가능성이 큰 자료 구조`일 수 있다.
- 장점
    - 내부의 변수가 변경되더라도 **모듈 내부에만 영향**을 끼침
    - 비즈니스 로직과 사용자 인터페이스에 대한 **관심사를 분리**
    - 네임스페이스 오염을 방지
        - 전역 네임스페이스의 오염을 방지하는 동시에 이름 충돌의 위험을 완화
- 단점
    - 인스턴스 개념을 제공하지 않는다.
- 기능이 아닌 **변경의 정도에 따라 시스템을 분해**하게 한다.
- 감춰야 할 데이터를 결정하고 이 데이터를 조작하는 데 필요한 함수를 결정
    
    → 데이터를 중심으로 시스템을 분해하는 것
    
- 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위

<br>

### 데이터 추상화

- 소프트웨어가 `무엇`을 알아야 하는지를 추상화
- 객체지향 (프로시저를 추상화)
- 추상 데이터 타입 (타입을 추상화)
    - 추상 객체의 클래스를 정의한 것으로 추상 객체에 사용할 수 있는 오퍼레이션을 이용해 규정된다.
    - 기본 의도는 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는 것
    - 추상 데이터 타입 구현을 위해 필요한 프로그래밍 언어의 지원
        - 타입 정의를 선언할 수 있어야 한다
        - 오퍼레이션의 집합을 정의할 수 있어야 한다
        - 데이터를 외부로부터 보호할 수 있어야 한다
        - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다
    - 시스템의 상태를 저장할 데이터를 표현
    - 추상 데이터 타입으로 표현된 데이터를 이용해서 기능을 구현하는 **`핵심 로직`**은 추상데이터 **타입 외부에 존재**
    - 타입 : 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미

<br>

### 클래스

- 추상 데이터 타입과 클래스는 동일하지 않다.
    
    → **상속과 다형성 지원 여부의 차이**. 클래스만 지원한다.
    
- 추상 데이터 타입 기반의 프로그래밍 패러다임은 `객체기반 프로그래밍`이라고 부름.
- `추상 데이터 타입`은 **타입을 추상화**한 것. `클래스`는 **절차를 추상화**한 것.
    - **타입 추상화**
        - `하나의 대표적인 타입`이 **다수의 세부적인 타입을 감춤**.
        - 오퍼레이션을 기준으로 타입을 통합하는 데이터 추상화 기법
        - 데이터 중심적인 관점.
    - **객체지향**
        - `타입을 기준`으로 **오퍼레이션을 묶는다.**
        - 공통 로직은 부모클래스를 정의해서 상속받게 하여 구현.
        - 클라이언트 입장에서 각 클래스의 인스턴스는 동일하게 보인다.
        - 실제 내부에서 수행되는 절차는 다르지만, 다형성은 절차에 대한 차이점을 감춘다.
        - 서비스 중심적인 관점.
- 클래스가 추상 데이터 타입의 개념을 따르는지 확인하는 방법
    - 내부에 `인스턴스의 타입을 표현하는 변수`가 있는지 확인해보기.
    - 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주
    - 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체.
- OCP : 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성
- 추상 데이터 타입과 객체지향 설계의 유용성은 설계에 요구되는 변경의 압력이 `타입 추가`에 관한 것인지, `오퍼레이션 추가`에 관한 것인지에 따라 다르다.