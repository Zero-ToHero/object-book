### 개방-폐쇄 원칙 (Open-Closed Principle)
-  소프트웨어 개체는 확장에는 열려 있고, 수정에는 닫혀 있어야 한다
-  확장에 대해 열려있다
    - 요구사항 변경 시 새로운 동작을 추가하여 기능을 확장 가능
기존 코드 수정 없이 애플리케이션 기능을 확장할 수 있어야 함
- 수정에 대해 닫혀있다
    - 기존 코드를 수정하지 않고도 새로운 동작을 추가하거나 변경 가능
추상화에 의존함으로써 기존 코드를 보호
### 추상화 
-  핵심적인 부분만 남기고 불필요한 부분을 생략하여 복잡성을 줄이는 기법
- 수정에 닫혀 있고, 설계의 확장을 가능하게 함
- 객체 생성과 사용을 분리하면 유연하고 재사용 가능한 설계가 가능
### 시스템 객체 분해 방법
1. 표현적 분해
- 도메인의 사물/개념을 표현하는 객체로 시스템을 분해
2. 행위적 분해
- 객체의 행위(책임과 역할)에 따라 시스템을 분해
### Pure Fabrication (순수한 가공물)
도메인과 무관한 인공적인 객체를 창조하여 책임을 할당
도메인 개념이 불충분할 경우 사용
### 의존성 관리
- 의존성 주입: 외부 독립 객체가 인스턴스를 생성 후 전달하여 의존성을 해결
- 메서드 호출 주입: 메서드가 의존성을 필요로 하는 유일한 경우 사용
### Service Locator 패턴
- 의존성을 해결할 객체들을 관리하는 저장소 역할
단점:
의존성을 감춤 → 캡슐화 위반
핵심: 명시적 의존성이 숨겨진 의존성보다 낫다
###  의존성 역전 원칙 (Dependency Inversion Principle)
- 상위 수준 모듈은 하위 수준 모듈에 의존하지 않고, 둘 모두 추상화에 의존해야 함
- 추상화는 구체적인 사항에 의존하지 않음. 구체적인 사항이 추상화에 의존해야 함
- 유연하고 재사용 가능한 설계를 얻기 위해 의존성을 역전
---

- 역할, 책임, 협력에 초점을 맞춘 설계
- 객체 생성에 집착하지 않고, 객체의 역할과 책임 먼저 정의
- 성급한 객체 생성은 불필요한 세부사항에 결합을 초래함
- 모든 의존성의 방향을 추상화를 따르도록 설계
- 구체 클래스는 의존성의 시작점이어야 하고 목적지가 되어선 안 됨



