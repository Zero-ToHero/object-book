# Chapter 01. 객체, 설계

- **이론과 실무의 관계**:

대부분의 사람들은 이론이 먼저 정립된 후에 실무가 그 뒤를 따라 발전한다고 생각한다.

하지만 글래스는 그 반대라고 주장한다. 

이유는 실무가 어느 정도 발전하고 난 다음에야 실무를 입증할 수 있는 이론이 서서히 모습을 갖춰가기 때문이다.

##  소프트웨어 모듈의 세 가지 목적 :
    1. 실행 중에 제대로 동작하는 것이다.
    2. 변경을 위해 존재하는 것이다.
    3. 코드를 읽는 사람과 의사소통 하는 것이다.

- 의존성과 결합도:
    - 설계의 목표는 *객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것*이어야 한다.
    - 목표는 애플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다.

- 캡슐화와 자율성:
    - 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.
    - 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.

- 응집도:
    - 객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다.
    - 객체는 자신의 **데이터를 스스로 처리하는 자율적인 존재**여야 한다.

- 객체지향 프로그래밍:
    - **데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식이다.
    - 이것의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.
    - **두 방식 사이에 근본적인 차이를 만드는 것은 책임의 이동**이다.
    - 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다.
    -  각 객체는 자신을 스스로 책임진다.
   

- 객체지향 설계의 핵심:
    -  객체가 어떤 데이터를 가지느냐보다는 *객체에 어떤 책임을 할당할 것이냐에 초점*을 맞춰야 한다.

- 설계의 트레이드오프:
    - 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
    - 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다.

- 의인화:
    - 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙이다.
    - 훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다.
    - 이해하기 쉽고 변경하기 쉬운 코드를 작성하고 싶다면 한 편의 애니메이션을 만든다고 생각하기.

- 설계와 구현:
    - 설계를 구현과 떨어뜨려서 이야기하는 것은 불가능하다.
    - **설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정**에서 나온다.
    - 설계는 코드 작성의 일부이며 코드를 작성하지 않고서는 검증할 수 없다.

- 좋은 설계란:
    - 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다.
    - 변경을 수용할 수 있는 설계가 중요한 이유는 요구사항이 항상 변경되기 때문이다.
    - 또 다른 이유는 코드를 변경할 때 버그가 추가될 가능성이 높기 때문이다.

- 진정한 객체지향 설계:
    - 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다.
    - 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이다.