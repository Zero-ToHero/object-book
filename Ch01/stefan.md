# Ch01. 객체, 설계

### 티켓 판매 앱 구현

- 관람객 - `가방`
- 가방 - `돈`, `티켓`, `초대장`
- 매표소 - `돈`, `티켓`
- 판매원 - `매표소`
- 소극장 - `판매원`

### 이상한 점

- Theater의 enter 메소드

  - 소극장이 `입장` 메소드를 통해서 `관람객`을 입장시킴.
  - 소극장이 `관람객`의 `가방`에서 `초대장`이 있는지 확인함.
  - 있으면 -> `판매원`에게 `티켓`을 꺼내서 `관람객`의 `가방`에 넣어준다.
    - `관람객`의 `가방`에서 `초대장`을 뺀다.
  - 없으면 -> `판매원`에게 `티켓`을 꺼내서 `관람객`의 `가방`에 넣어준다.
    - `관람객`의 `가방`에서 `돈`을 뺀다.
    - `판매원`에게 `매표소`의 금고에 그 `돈`을 넣으라고 시킨다.

- 왜 이상함?
  - 현실 세계와 다르다.
    - `소극장`이 `관람객`과 `판매원`을 컨트롤?
    - `가방`에서 `초대장`, `돈`을 막 뺌?
      -> 예상대로 동작하지 않아서 이해가 어렵다 (현실과 다름, 상식적이지 못함)
      -> 기억할 내용이 너무나 많음. (무슨 클래스가 어떤 메소드를 가지고 있고...)
  - 변경 용이성 좋지 않음.
    - 객체 간 의존성이 얽혀있음. (결합도)
      - `관람객`이나 `판매원`이 변경되면 `소극장`도 변경 필요.

```
로버트 마틴의 소프트웨어 모듈의 세 가지 목적
1. 제대로 동작 (잘 동작)
2. 변경을 위해 존재 (변경에 유연)
3. 코드를 읽는 사람과 의사소통하는 것 (가독성)
```

=> 이중 2,3번을 위반.

### 설계 개선하기

- 문제: 요구사항이 바뀌면 변경 범위가 엄청 넓음.

  1. 의존성이 얽혀있으니 좀 끊자.

  - `관람객` or `판매원` 변경 -> `소극장`도 변경해야하는 상황.
  - 어떻게 바꿈? -> `관람객`과 `판매원`이 스스로 일처리 하도록 바꾸자

    - 불필요한 정보는 외부와 차단하기
    - 매표소는 판매원만 접근 가능하게
    - 가방은 관람객만 접근 가능하게

  - 변경 결과
    -> 관람객이 가방을 알아서 컨트롤 / 판매원이 매표소를 알아서 컨트롤 = 자율적인 존재
    -> 캡슐화 -> 자율적인 존재 -> 결합도를 낮춘다.
    -> 현실과 동일하게 동작 -> 예측 가능, 직관적

  2. 소극장의 입장(enter) 메소드는 `1번 과정`을 통해서 인터페이스에 의존하게됨. (원래는 세부 구현에 의존)

  - 변경 결과
    -> 내부 구현을 바꾸더라도 소극장은 변경하지 않아도 됨.

=> 객체 내부의 상태 `캡슐화` + 객체 간 `메시지`를 통해서만 상호작용하도록 만들기
=> 객체 스스로 자신의 데이터를 책임져야 응집도를 높일 수 있다.

```
객체 사이의 의존성이 과한 경우 - 결합도(coupling)가 높다.
연관 있는 작업만 수행, 연관 엾는 작업은 다른 객체에 위임하도록 잘 설계된 객체 - 응집도(cohesion)가 높다.
```

- 객체지향 프로그래밍

  - 절차지향에서는 프로세스 / 데이터 별도 모듈에 위치
    - 따라서 책임을 가지고 있지 않음.
    - 변경에 취약.
  - 객체지향에서는 프로세스 + 객체 동일 모듈 내부에 위치
    - 객체마다 책임이 있음.
    - 그래서 자율적.
    - 각 객체는 필요한 경우에만 의존.
    - 모든 객체가 공동체의 구성원으로 상호작용하여 완성됨.

- 개선 -> 트레이드오프 시점이 온다.

  1. 설계 방법은 여러가지일 수 있다.
  2. 그렇기에 설계는 트레이드오프의 산물이다.

- 좋은 설계란 ?
  -> 기능을 온전히 수행 + 변경에 유연
  -> 그 전에 **이해하기 쉬운 코드**를 작성해야한다.
